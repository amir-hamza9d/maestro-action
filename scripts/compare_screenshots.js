/**
 * Visual Regression Testing Script for Maestro
 *
 * This script compares screenshots taken during test execution with baseline screenshots
 * and generates difference images highlighting the mismatches.
 *
 * Directory structure:
 * Screen-shots/
 * ‚îú‚îÄ‚îÄ Expected/  (baseline screenshots)
 * ‚îú‚îÄ‚îÄ Actual/    (screenshots captured during test runs)
 * ‚îî‚îÄ‚îÄ Diff/      (difference images generated by this script)
 *
 * Dependencies:
 * - pixelmatch: For pixel-by-pixel image comparison
 * - pngjs: For PNG image processing
 * - fs-extra: For enhanced file system operations
 */

const fs = require('fs-extra');
const path = require('path');
const { PNG } = require('pngjs');
const pixelmatch = require('pixelmatch');

// Directory paths
const BASE_DIR = path.join(process.cwd(), 'Screen-shots');
const EXPECTED_DIR = path.join(BASE_DIR, 'Expected');
const ACTUAL_DIR = path.join(BASE_DIR, 'Actual');
const DIFF_DIR = path.join(BASE_DIR, 'Diff');

// Debug mode - set to true to enable additional logging
const DEBUG = false;

// Check if directories exist
function checkDirectories() {
  console.log('‚úÖ Checking if required directories exist...');
  if (!fs.existsSync(BASE_DIR)) {
    throw new Error(`‚ùå Screen-shots directory does not exist: ${BASE_DIR}`);
  }
  if (!fs.existsSync(EXPECTED_DIR)) {
    throw new Error(`‚ùå Expected screenshots directory does not exist: ${EXPECTED_DIR}`);
  }
  if (!fs.existsSync(ACTUAL_DIR)) {
    throw new Error(`‚ùå Actual screenshots directory does not exist: ${ACTUAL_DIR}`);
  }
  if (!fs.existsSync(DIFF_DIR)) {
    throw new Error(`‚ùå Diff directory does not exist: ${DIFF_DIR}`);
  }
  console.log('‚úÖ All required directories exist.');
}

// Read PNG image from file
function readImage(filePath) {
  return new Promise((resolve, reject) => {
    try {
      const data = fs.readFileSync(filePath);
      const png = PNG.sync.read(data);
      resolve(png);
    } catch (error) {
      reject(error);
    }
  });
}

// Compare two images and generate a diff image
async function compareImages(expectedPath, actualPath, diffPath) {
  try {
    console.log(`üîç Comparing: Actual ${path.basename(actualPath)} with Baseline ${path.basename(expectedPath)}`);

    const expected = await readImage(expectedPath);
    const actual = await readImage(actualPath);

    // Check if dimensions match
    if (expected.width !== actual.width || expected.height !== actual.height) {
      console.error(`‚ùå Error: Image dimensions don't match between Actual ${path.basename(actualPath)} and Baseline ${path.basename(expectedPath)}`);
      console.error(`‚ÑπÔ∏è Expected: ${expected.width}x${expected.height}, Actual: ${actual.width}x${actual.height}`);
      return {
        match: false,
        error: 'Dimension mismatch',
        diffPixels: null
      };
    }

    // Create diff image
    const diff = new PNG({ width: expected.width, height: expected.height });

    // Compare images pixel by pixel
    const diffPixels = pixelmatch(
      expected.data,
      actual.data,
      diff.data,
      expected.width,
      expected.height,
      {
        threshold: 0.1,          // Threshold for considering pixels different
        alpha: 0.7,              // Alpha for unchanged pixels
        diffColor: [255, 0, 0],  // Red diff color
        diffColorAlt: [255, 0, 0], // Alternative diff color (also red)
        aaColor: [255, 0, 0],    // Anti-aliasing color (also red)
        includeAA: true,         // Include anti-aliased pixels in diff
        fade: false,             // Don't fade unchanged pixels
        outputDiff: true         // Output actual visual differences
      }
    );

    // Save diff image if there are differences
    if (diffPixels > 0) {
      // Let's take a completely different approach to ensure we only highlight actual differences

      // First, let's save the original pixelmatch diff for debugging
      if (DEBUG) {
        const debugDiffPath = path.join(DIFF_DIR, `debug_${path.basename(diffPath)}`);
        fs.writeFileSync(debugDiffPath, PNG.sync.write(diff));
        console.log(`üêõ Debug diff saved to ${path.basename(debugDiffPath)}`);
      }

      // Create a new PNG for our custom diff
      const clearDiff = new PNG({ width: expected.width, height: expected.height });

      // First, copy the actual image as the base
      for (let y = 0; y < actual.height; y++) {
        for (let x = 0; x < actual.width; x++) {
          const idx = (actual.width * y + x) << 2;

          // Copy actual image pixel (always preserve the original image)
          clearDiff.data[idx] = actual.data[idx];         // R
          clearDiff.data[idx + 1] = actual.data[idx + 1]; // G
          clearDiff.data[idx + 2] = actual.data[idx + 2]; // B
          clearDiff.data[idx + 3] = actual.data[idx + 3]; // A
        }
      }

      // Now, compare the expected and actual images directly
      let diffCount = 0;
      for (let y = 0; y < actual.height; y++) {
        for (let x = 0; x < actual.width; x++) {
          const idx = (actual.width * y + x) << 2;

          // Compare RGB values with a small threshold to account for compression artifacts
          const rDiff = Math.abs(expected.data[idx] - actual.data[idx]);
          const gDiff = Math.abs(expected.data[idx + 1] - actual.data[idx + 1]);
          const bDiff = Math.abs(expected.data[idx + 2] - actual.data[idx + 2]);

          // If any channel differs by more than our threshold, mark as different
          if (rDiff > 5 || gDiff > 5 || bDiff > 5) {
            diffCount++;

            // Make the difference pixel pink and fully opaque
            clearDiff.data[idx] = 255;       // R (255)
            clearDiff.data[idx + 1] = 105;   // G (105)
            clearDiff.data[idx + 2] = 180;   // B (180) - Hot Pink
            clearDiff.data[idx + 3] = 255;   // A (fully opaque)

            // Add a yellow border around the difference for better visibility
            const highlightDiff = (x, y) => {
              if (x >= 0 && x < actual.width && y >= 0 && y < actual.height) {
                const highlightIdx = (actual.width * y + x) << 2;

                // Skip if this is already a difference pixel
                const isAlreadyDiff =
                  Math.abs(expected.data[highlightIdx] - actual.data[highlightIdx]) > 5 ||
                  Math.abs(expected.data[highlightIdx + 1] - actual.data[highlightIdx + 1]) > 5 ||
                  Math.abs(expected.data[highlightIdx + 2] - actual.data[highlightIdx + 2]) > 5;

                if (!isAlreadyDiff) {
                  // Add a more prominent, bold yellow highlight
                  clearDiff.data[highlightIdx] = 255;     // R (255) - Full red
                  clearDiff.data[highlightIdx + 1] = 255; // G (255) - Full green
                  clearDiff.data[highlightIdx + 2] = 0;   // B (0)   - No blue = bright yellow
                  // Make the border fully opaque for maximum visibility
                  clearDiff.data[highlightIdx + 3] = 255; // A (255) - Fully opaque
                }
              }
            };

            // Add highlights to surrounding pixels - thicker border (2px)
            // Direct neighbors (1px away)
            highlightDiff(x-1, y);   // Left
            highlightDiff(x+1, y);   // Right
            highlightDiff(x, y-1);   // Top
            highlightDiff(x, y+1);   // Bottom

            // Diagonal neighbors (1px away)
            highlightDiff(x-1, y-1); // Top-left
            highlightDiff(x+1, y-1); // Top-right
            highlightDiff(x-1, y+1); // Bottom-left
            highlightDiff(x+1, y+1); // Bottom-right

            // Extended border (2px away)
            highlightDiff(x-2, y);   // Far left
            highlightDiff(x+2, y);   // Far right
            highlightDiff(x, y-2);   // Far top
            highlightDiff(x, y+2);   // Far bottom
          }
        }
      }

      // Update diffPixels with our own count
      // Note: We're not logging the raw pixel count here to keep the output cleaner
      if (diffCount === 0 && diffPixels > 0) {
        console.log(`‚ö†Ô∏è Warning: pixelmatch found ${diffPixels} differences but our direct comparison found none.`);
      }

      // Save the enhanced diff image
      fs.writeFileSync(diffPath, PNG.sync.write(clearDiff));
      console.log(`üîç Differences found: ${diffCount} pixels highlighted in pink with bold yellow borders between Actual ${path.basename(actualPath)} and Baseline ${path.basename(expectedPath)}. Diff saved to ${path.basename(diffPath)}`);

      // Use our direct comparison result instead of pixelmatch's result
      diffPixels = diffCount;
    } else {
      console.log(`‚úÖ No differences found between Actual ${path.basename(actualPath)} and Baseline ${path.basename(expectedPath)}`);
    }

    return {
      match: diffPixels === 0,
      diffPixels: diffPixels,
      error: null
    };
  } catch (error) {
    console.error(`‚ùå Error comparing images: ${error.message}`);
    return {
      match: false,
      error: error.message,
      diffPixels: null
    };
  }
}

// Main function to run the comparison
async function runComparison() {
  console.log('üöÄ Starting visual regression testing...');
  checkDirectories();

  // Get all files in the Expected directory
  const expectedFiles = fs.readdirSync(EXPECTED_DIR)
    .filter(file => file.toLowerCase().endsWith('.png'));

  if (expectedFiles.length === 0) {
    console.log('‚ö†Ô∏è No baseline screenshots found in Expected directory.');
    return;
  }

  console.log(`üìä Found ${expectedFiles.length} baseline screenshots.`);

  // Results tracking
  const results = {
    total: expectedFiles.length,
    matched: 0,
    differences: 0,
    errors: 0,
    missing: 0
  };

  // Compare each expected file with its actual counterpart
  for (const file of expectedFiles) {
    const expectedPath = path.join(EXPECTED_DIR, file);
    const actualPath = path.join(ACTUAL_DIR, file);
    const diffPath = path.join(DIFF_DIR, file);

    // Check if actual file exists
    if (!fs.existsSync(actualPath)) {
      console.error(`‚ùå Error: Actual screenshot not found for Baseline ${file}`);
      results.missing++;
      continue;
    }

    // Compare images
    const result = await compareImages(expectedPath, actualPath, diffPath);

    if (result.error) {
      results.errors++;
    } else if (result.match) {
      results.matched++;
    } else {
      results.differences++;
    }
  }

  // Print summary
  console.log('\nüìã Visual Regression Test Summary:');
  console.log(`üìä Total baseline screenshots: ${results.total}`);
  console.log(`‚úÖ Matching screenshots: ${results.matched}`);
  console.log(`üîç Screenshots with differences: ${results.differences}`);
  console.log(`‚ùå Screenshots with errors: ${results.errors}`);
  console.log(`‚ö†Ô∏è Missing actual screenshots: ${results.missing}`);

  // Return non-zero exit code if there are differences or errors
  if (results.differences > 0 || results.errors > 0 || results.missing > 0) {
    console.log('\n‚ùå Visual regression tests FAILED.');
    process.exit(1);
  } else {
    console.log('\n‚úÖ Visual regression tests PASSED.');
    process.exit(0);
  }
}

// Run the comparison
runComparison().catch(error => {
  console.error('‚ùå Unhandled error:', error);
  process.exit(1);
});
